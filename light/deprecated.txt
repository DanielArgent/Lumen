		/*public class Dispatcher : SystemFun {
			public List<Fun> funcs = new List<Fun>();

			public void Add(UserFun fun) {
				this.funcs.Add(fun);
			}

			public override Value Run(Scope e, params Value[] args) {
				Int32 argsCount = 0;
				List<String> vars = new List<string> { "self", "args", "kwargs", "this" };
				foreach(var i in e.variables) {
					if (!vars.Contains(i.Key)) {
						argsCount++;
					}
				}
				argsCount += args.Length;

				List<Fun> candidates = new List<Fun>();

				foreach(Fun i in this.funcs) {
					if(i.Metadata.args.Count == argsCount) {
						candidates.Add(i);
					}
				}

				Dictionary<String, Object> arguments = new Dictionary<String, Object>();
				Int32 counter = 0;

				foreach (FunctionArgument i in candidates[0].Metadata.args) {
					if (e.ExistsInThisScope(i.name.Replace("*", ""))) {
						arguments.Add(i.name.Replace("*", ""), e.Get(i.name.Replace("*", "")));
						continue;
					}

					if (counter < args.Length) {
						if (i.name.StartsWith("*")) {
							List<Value> v = new List<Value>();

							for (Int32 z = counter; z < args.Length; z++) {
								v.Add(args[z]);
								counter++;
							}

							arguments.Add(i.name.Substring(1, i.name.Length - 1), new List(v));
							continue;
						}

						arguments.Add(i.name, args[counter]);
						counter++;
					}
					else {
						arguments.Add(i.name, i.defaultValue);
					}
				}

				counter = 0;

				foreach (FunctionArgument i in candidates[0].Metadata.args) {
					if (e.ExistsInThisScope(i.name.Replace("*", ""))) {
						continue;
					}

					if (counter < args.Length || (args.Length == 0 && counter == args.Length)) {
						if (i.name.StartsWith("*")) {
							List<Value> v = new List<Value>();

							for (Int32 z = counter; z < args.Length; z++) {
								v.Add(args[z]);
								counter++;
							}

							e.Set(i.name.Substring(1, i.name.Length - 1), new List(v));
							continue;
						}

						if (args.Length != 0) {
							e.Set(i.name, args[counter]);
							counter++;
						}
						else {
							if (i.defaultValue != null) {
								if (i.defaultValue is Value val) {
									e.Set(i.name, val);
								}
								else if (i.defaultValue is Expression exp) {
									e.Set(i.name, exp.Eval(e));
								}
							}
							else {
								e.Set(i.name, Const.NULL);
							}

							counter++;
						}
					}
					else {
						if (i.defaultValue != null) {
							if (i.defaultValue is Value val) {
								e.Set(i.name, val);
							}
							else if (i.defaultValue is Expression exp) {
								e.Set(i.name, exp.Eval(e));
							}
						}
						else {
							e.Set(i.name, Const.NULL);
						}
					}
				}


				foreach (UserFun i in candidates) {
					if (i.Metadata.IsMatch(arguments)) {
						if (i.condition != null && !Converter.ToBoolean(i.condition.Eval(e))) {
							continue;
						}
						return i.Run(e, args);
					}
				}

				throw new StandartLibrary.Exception("dispatch", stack: e);
			}
		}
		*/
//////////////////////////////////////////////////////////
		internal static Expression MakeClosure(List<String> zex, Expression i, Scope e) {
			return i.Closure(zex, e);

			if (i is Namespace) {
				zex.Add(((Namespace)i).name);
			}

			if (i is DecoratorE dece) {
				return new DecoratorE(dece.expsOfDecos.Select(x => MakeClosure(zex, x, e)).ToList(), MakeClosure(zex, dece.func, e));
			}

			if (i is AnonymeDefine) {
				var z = new List<string> { "self", "_", "this" };

				foreach (var x in ((AnonymeDefine)i).Args)
					z.Add(x.name.Replace("*", ""));
				foreach (string x in zex)
					z.Add(x);

				return new AnonymeDefine(((AnonymeDefine)i).Args, MakeClosure(z, ((AnonymeDefine)i).Body, e));
			}

			if (i is FunctionDefineStatement fde) {
				/*    var z = new List<string> { "self" };*/

				/* foreach (string x in fde.Args.GetNames())
                     z.Add(x.Replace("&", "").Replace("*", ""));
                     */
				/*    foreach (string x in zex)
                        z.Add(x);*/

				zex.Add(fde.NameFunction);
				//   z.Add(fde.NameFunction);

				// ((FunctionDefineStatement)i).Body = ReWrite(fde.NameFunction, z, fde.Body, e);
			}

			if (i is WhileExpression we)
				return new WhileExpression(MakeClosure(zex, we.condition, e), MakeClosure(zex, we.body, e));

			if (i is DotApplicate dapp) {
				return new DotApplicate(MakeClosure(zex, dapp.res, e), dapp.exps.Select(x => MakeClosure(zex, x, e)).ToList());
			}

			if (i is Assigment ae) {
				zex.Add(ae.id);
				return new Assigment(ae.id, MakeClosure(zex, ae.exp, e), ae.line, ae.file);
			}

			if (i is SpreadE)
				return new SpreadE(MakeClosure(zex, ((SpreadE)i).expression, e));

			if (i is ListForGen lfg) {
				return new ListForGen(lfg.names, MakeClosure(zex, lfg.container, e), MakeClosure(zex, lfg.body, e));
			}

			if (i is ConditionE cde)
				return new ConditionE(MakeClosure(zex, cde.condition, e), MakeClosure(zex, ((ConditionE)i).trueExpression, e), MakeClosure(zex, ((ConditionE)i).falseExpression, e));

			if (i is DotExpression dte)
				return new DotExpression(MakeClosure(zex, dte.expression, e), dte.nameVariable);

			if (i is IdExpression ce) {
				if (!ce.id.StartsWith("$"))
					if (!(zex.Contains(ce.id))) {
						if (!e.IsExsists(ce.id))
							throw new Lumen.Lang.Std.Exception($"\n\tFILE: {ce.file} LINE: {ce.line}\n\t неизвестный идентификатор {ce.id}", stack: e);
						return new ValueE(e.Get(ce.id));
					}
				return i;
			}

			if (i is BinaryExpression) {
				BinaryExpression z = (BinaryExpression)i;
				return new BinaryExpression(MakeClosure(zex, z.expressionOne, e), MakeClosure(zex, z.expressionTwo, e), z.operation, z.line, z.file);
			}

			return i;
		}