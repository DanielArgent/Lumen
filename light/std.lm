[module]
let std()

[const]
let std.false := ...
[const]
let std.true := ...
[const]
let std.void := ...
[const]
let std.NL := ...
[const]
let std.OS := ...
[const]
let std.POS_INF := ...
[const]
let std.NEG_INF := ...
[const]
let std.NaN := ...
[const]
let std.PIS := 0..POS_INF
[const]
let std.NIS := 0..NEG_INF
[const]
let std.PI := ...
[const]
let std.E := ...

let std.print(...args, sep:=" ", on_end:=NL, file:=void, write:=false) := ...
let std.input(message:=""): str := ...

let std.sealed(func) := ...
let std.enum(func) := ...
let std.module(func) := ...
let std.constructor() := ...
let std.derived() := ...
let std.const() := ...
let std.iterator() := ...
let std.dataclass() := ...
let std.comparable() := ...

# Type of empty value
[constructor]
let std.void() := ...

let std.optional(value) := ...

# Type of logical value
[sealed] 
[comparable] 
[constructor]
let std.bool() := false
# Parse string into a logical value
# Returns a std.bool value if success, otherwise - returns std.void
let std.bool.parse(text: std.str): std.bool | std.void := ...

let std.bool.not(): std.bool := ...
let std.bool.or(other: std.bool): std.bool := ...
let std.bool.and(other: std.bool): std.bool := ...

# Type of finite floating numbers
[sealed] 
[comparable] 
[constructor]
let std.num() := 0
# Returns equal number
let std.num.+(): std.num := ...
# Returns reflected number
let std.num.-(): std.num := ...
# Returns a range 0..this
let std.num.^(): std.seq := ...
# Returns result of byte not 
# Works only for integers
let std.num.^(): std.num | std.void := ...
# Returns a sum of two numbers
let std.num.+(other: std.num | std.bignum): std.num | std.bignum := ...
# Returns a substract of two numbers
let std.num.-(other: num | std.bignum): std.num | std.bignum := ...
# Returns a produce of two numbers
let std.num.*(other: num | std.bignum): std.num | std.bignum := ...
# Returns a divide of two numbers
let std.num./(other: num | std.bignum): std.num | std.bignum := ...
# Returns a byte or 
# Works only for integers
let std.num.|(other: num | std.bignum): std.num | std.bignum | std.void := ...
# Returns a byte xor
# Works only for integers
let std.num.^(other: num | std.bignum): std.num | std.bignum | std.void := ...
# Returns a byte and 
# Works only for integers
let std.num.&(other: num | std.bignum): std.num | std.bignum | std.void := ...
# Returns a byte left shift
let std.num.<<(other: num | std.bignum): std.num | std.bignum | std.void := ...
# Returns a byte right shift
let std.num.>>(other: num | std.bignum): std.num | std.bignum | std.void := ...
# Returns this in power of other
let std.num.**(other: num | std.bignum): std.num | std.bignum := ...
# Returns inclusive range (...)
let std.num.rngi(other: num | std.bignum): std.num | std.bignum := ...
# Returns exclusive range (..)
let std.num.rnge(other: num | std.bignum): std.num | std.bignum := ...
# Returns a integer form division
let std.num.div(other: std.num | std.bignum): std.num | std.bignum := ...
# [not founded]
let std.num.mod(other: std.num | std.bignum): std.num | std.bignum := ...
# [not founded]
let std.num.rem(other: std.num | std.bignum): std.num | std.bignum := ...
# Check for equality
let std.num.=(other): std.bool := ...
# Check for not equality
let std.num.<>(other): std.bool := ...
# [not founded]
let std.num.<(other: std.num | std.bignum): std.bool := ...
# [not founded]
let std.num.>(other: std.num | std.bignum): std.bool := ...
# [not founded]
let std.num.<=(other: std.num | std.bignum): std.bool := ...
# [not founded]
let std.num.>=(other: std.num | std.bignum): std.bool := ...
# [not founded]
let std.num.<=>(other: std.num | std.bignum): std.num := ...

let std.num.times(action: std.fun[num, void] | std.fun[void]): std.void
let std.num.count(action: std.fun[num, X] | std.fun[X]): std.seq[X]

[comparable] 
[constructor]
let std.vec(...args) := ...

let std.vec.*(): std.num := ...
let std.vec.+(other): std.vec := ...
let std.vec.-(other): std.vec := ...
let std.vec.*(other: std.num | std.str | std.fun): std.vec | std.str | std.vec := ...
let std.vec./(other: std.fun | std.num) := ...
let std.vec.&(other: std.vec | std.seq): std.vec := ...
let std.vec.|(other: std.vec | std.seq): std.vec := ...
let std.vec.+=(other) := this.add(other)

let std.vec.get_index(...args) := ...
let std.vec.set_index(...args, value) := ...

let std.vec.seq(): std.seq := ...
let std.vec.str(): std.str := ...

let std.vec.add(...elements): std.num := ...

let std.vec.pop() := ...
let std.vec.shift(element) := ...
let std.vec.insert(position, element) := ...
let std.vec.remove(...elements) := ...
let std.vec.remove_at(position) := ...
let std.vec.unshift() := ...
let std.vec.reject(predicate) := ...

let std.vec.index(element) := ...
let std.vec.rindex(element) := ...
let std.vec.findex(predicate) := ...
let std.vec.frindex(predicate) := ...
let std.vec.contains(object) := ...
let std.vec.exists(predicate) := ...
let std.vec.find(predicate) := ...
let std.vec.rfind(predicate) := ...
let std.vec.find_all(predicate) := ...

let std.vec.all(predicate) := ...
let std.vec.any(predicate) := ...

let std.vec.sort(fn:=void, rev:=false): std.vec := ...
let std.vec.sort_m(fn:=void, rev:=false): std.void := ...

let std.vec.reverse(): std.vec := ...
let std.vec.reverse_m(fn:=void, rev:=false): std.void := ...

let std.vec.flatten(): std.void := ...
let std.vec.partition(predicate): std.void := ...

let std.vec.clear(): std.void := ...

let std.vec.each(element) := ...
let std.vec.each_m(predicate) := ...
let std.vec.select(element) := ...
let std.vec.reduce(predicate) := ...
let std.vec.action(object) := ...
let std.vec.count(predicate) := ...
let std.vec.each_slice(predicate) := ...
let std.vec.cycle(predicate) := ...

let std.vec.first() := ...
let std.vec.last() := ...
let std.vec.min() := ...
let std.vec.max() := ...
let std.vec.sum() := ...
let std.vec.produce() := ...

let std.vec.take(n) := ...
let std.vec.skip(n) := ...
let std.vec.take_while(predicate) := ...
let std.vec.skip_while(predicate) := ...

let std.vec.unique() := ...
let std.vec.zip() := ...
let std.vec.join() := ...

[constructor]
let std.seq() := ...

let std.seq.*(): std.num := ...
let std.seq.+(other): std.vec := ...
let std.seq.-(other): std.vec := ...
let std.seq.*(other: std.num | std.str | std.fun): std.vec | std.str | std.vec := ...
let std.seq./(other: std.fun | std.num) := ...
let std.seq.&(other: std.vec | std.seq): std.vec := ...
let std.seq.|(other: std.vec | std.seq): std.vec := ...
let std.seq.+=(other) := this.add(other)

let std.seq.vec(): std.vec := ...
let std.seq.str(): std.str := ...

let std.seq.index(element) := ...
let std.seq.rindex(element) := ...
let std.seq.findex(predicate) := ...
let std.seq.frindex(predicate) := ...
let std.seq.contains(object) := ...
let std.seq.exists(predicate) := ...
let std.seq.find(predicate) := ...
let std.seq.rfind(predicate) := ...
let std.seq.find_all(predicate) := ...

let std.seq.all(predicate) := ...
let std.seq.any(predicate) := ...

let std.seq.sort(fn:=void, rev:=false): std.vec := ...
let std.seq.sort_m(fn:=void, rev:=false): std.void := ...

let std.seq.reverse(): std.vec := ...
let std.seq.reverse_m(fn:=void, rev:=false): std.void := ...

let std.seq.flatten(): std.void := ...
let std.seq.partition(predicate): std.void := ...

let std.seq.clear(): std.void := ...

let std.seq.each(element) := ...
let std.seq.each_m(predicate) := ...
let std.seq.select(element) := ...
let std.seq.reduce(predicate) := ...
let std.seq.action(object) := ...
let std.seq.count(predicate) := ...
let std.seq.each_slice(predicate) := ...
let std.seq.cycle(predicate) := ...

let std.seq.first() := ...
let std.seq.last() := ...
let std.seq.min() := ...
let std.seq.max() := ...
let std.seq.sum() := ...
let std.seq.produce() := ...

let std.seq.take(n) := ...
let std.seq.skip(n) := ...
let std.seq.take_while(predicate) := ...
let std.seq.skip_while(predicate) := ...

let std.seq.unique() := ...
let std.seq.zip() := ...
let std.seq.join() := ...

# <region IO-FUNCTIONS>

let read_number(prompt:=DEFAULT_STRING) := 
    input(prompt).num()

let read_bool(prompt:=DEFAULT_STRING) :=  
    bool.parse(input(prompt))

let read_string2(prompt1:=DEFAULT_STRING, prompt2:=DEFAULT_STRING) :=
    vec(input(prompt1), input(prompt2))

let read_number2(prompt1:=DEFAULT_STRING, prompt2:=DEFAULT_STRING) :=
    vec(read_number(prompt1), read_number(prompt2))

let read_bool2(prompt1:=DEFAULT_STRING, prompt2:=DEFAULT_STRING) :=
    vec(read_bool(prompt1), read_bool(prompt2))

let write(...params) :=
    print(...params, onend=DEFAULT_STRING)

let writeln(...params) :=
    print(...params)

let write_format(str, ...params) :=
    write(str % params)

let writeln_format(str, ...params) :=
    writeln(str % params)

let printf(str, ...params) :=
    writeln_format(str, ...params)

# </region>

let range(a, b, step:=1) {
    if step = 1 {
        return a...b
    }
    return (a...b).step(step)
}

# NOT WORKING WITH REAL, ONLY INTEGER
# AND GIVEN FOR ONE MORE
let partition(a, b, n) := 
    (a...b).step((b-a)/n)

let seq_random(n, a, b) := 
    (1...n).select(i := random(a, b))

let make_vec(size, value:=void) := 
    vec(value) * size

let fill_random(list, up=10, low=0) :=
    list.each!(i => Math.random(low, up))

let vec_random(n, up=10, low=0) {
    var result = if n is Number: make_list(n) else: n
    fill_random!(result)
    result
}

let max() :=
    args.max()

let min() :=
    args.min()

let sum() :=
    args.reduce(_ + _)

let mul() :=
    args.reduce(_ * _)

let iterate(i1, f) :=
    (for i in INF_POS_SEQ: i1 = f(i1))

# NOT WORKING
let iterate2(first, second, nex) :=
    (for i in INF_POS_SEQ {
        nxt = nex(first, second)
        first = second
        second = nxt
    })

let seq_gen(count: Number, i1, f) {
    iterate(i1, f).take(count)
}

let seq_while(i1, f, s) {
    iterate(i1, f).take_while(s)
}

# NOT WORKING
# eRROR IN CLOSURe
let seq_double_gen(i1, i2, f, s) {
    (for i in INF_POS_SEQ {
        t = i2
        i2 = f(i1, i2)
        i1 = t  
        if i1 >= s:
            break 1
        i1
    })
}

let ord(s: str): num := s.chars[0] 

let chr(c: num): str := c.char

let read_seq_string(n, prompt: String=DEFAULT_STRING) {
    range(1, n).each(() => input(prompt))
}

let read_seq_number(n, prompt: String=DEFAULT_STRING) {
    range(1, n).each(() => input(prompt).to_n())
}

let read_seq_bool(n, prompt: String=DEFAULT_STRING) {
    range(1, n).each(() => Boolean.parse(input(prompt)))
}

let read_seq_string_while(cond: Predicate[String], prompt: String=DEFAULT_STRING) {
    (for i in INF_POS_SEQ: {
        i = input(prompt)
        if not cond(i): 
            break
        i
    })
}

let read_seq_number_while(cond: Predicate[Number], prompt: String=DEFAULT_STRING) {
    (for i in INF_POS_SEQ: {
        i = input(prompt).to_n()
        if not cond(i): 
            break
        i
    })
}

let read_seq_bool_while(cond: Predicate[Boolean], prompt: String=DEFAULT_STRING) {
    (for i in INF_POS_SEQ: {
        i = Boolean.parse(input(prompt))
        if not cond(i): 
            break
        i
    })
}

# <region FILE FUNCTIONS>

let open(name) {
    new File(name)
}

let delete(file) {
    File.delete(file)
}

let dir(file) {
    File.dir(file)
}

let exist?(file) {
    File.exist?(file)
}

let append(file, text) {
    file.add!(text)
}


#</region>

let callable(obj) {
    obj.respond?("()")
}

let rad_to_deg(x: num) := 
    x * 180 / PI

let deg_to_rad(x: num) := 
    x * PI / 180
