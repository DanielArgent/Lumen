object t_object = extern("System.Object")
object t_int32 = extern("System.Int32")
object t_dbl = extern("System.Double")
object t_string = extern("System.String")

object convert = extern("System.Convert")
function to_int32 = extern_func(convert, "ToInt32", {t_dbl})
function to_string = extern_func(convert, "ToString", {t_object})

object object_list = extern("System.Collections.Generic.List`1[System.Object]")
function at = extern_func(object_list, "get_Item", {t_int32})

object array_list = extern("System.Collections.ArrayList")
function add = extern_func(array_list, "Add", {t_object})
function count = extern_func(array_list, "get_Count", {})
function get = extern_func(array_list, "get_Item", {t_int32})

function mkint(integer i)
    return to_int32(0, i)
end

function printf(object t, object x)
    print(t:as_text(x))
end

object ie = extern("System.Collections.Generic.IEnumerable`1[System.String]")
function join = extern_func(t_string, "Join", { t_string, ie })

array_list e = array_list:new()
add(e, 3)
add(e, "Hello!") 
add(e, { 4, 5, 2 })

printf(t_int32, count(e))

object_list o = get(e, mkint(2))
printf(t_int32, o)
printf(t_int32, at(o, mkint(2)))

object date_time = extern("System.DateTime")
function now = extern_func(date_time, "get_Now", {}) 
function year = extern_func(date_time, "get_Year", {})

date_time a = now(0)
printf(date_time, a)
printf(t_int32, year(a))

-------------------- TYPES -------------------------
type type

type contract

--|
--| Double floating point number
--|
type atom

--|
--| Character data
--|
type text

--|
--|
--|
type function

type list 

--|
--|
--|
type sequence

type iterator

--|
--|
--|
type namespace

--|
--|
--|
type bool

--|
--|
--|
type void

type error
    text mesage
end

type unexpected_nil : error

end

--|
--| Type of any not-nil value
--|
--| [example]
--|     print(object(4))              --> 1 (true)
--|     print(object({ 4, 2, 4, 5 })) --> 1 (true)
--| [end]
--|
contract object

--|
--| Integer number
--|
contract integer(atom a)

contract collection -- ?
---------------------- CONSTANTS ---------------------------
--|
--|
--|
constant bool true

--|
--|
--|
constant bool false

--|
--|
--|
constant void nil 

--|
--|
--|
constant text NL

------------------------- FUNCTIONS -------------------------------
--|
--|
--|
function text.new()

--|
--|
--|
function text.to_lower(text self)

--|
--|
--|
function text.to_upper(text self)

--|
--|
--|
function text.reverse(text self)

--|
--|
--|
function text.as_sequence(text self)

--|
--|
--|
function text.as_text(text self)

--|
--| Creates an empty sequence
--| 
function sequence.new()
function sequence.len(sequence self)
function sequence.map(sequence self, function fun)
function sequence.filter(sequence self, function fun)
function sequence.fold(sequence self, function fun)
function sequence.as_text(sequence self)

function iterator.new(sequence seq)
function iterator.get_current(iterator self)
function iterator.move(iterator self)
function iterator.reset(iterator self)
function iterator.as_text(iterator self)

--|  
--|
--|
function function.combine(function fun1, function fun2)

function print(object obj)
function printf(text format, sequence args)
function print_it(type controller, object arg)
function read()

function equals(object obj1, object obj2)

function load_asm(text asm_name)

-- returns type (class, struct or interface) if success, else returns 0
function extern_type(text name)

-- returns namespace (static class) if success, else returns 0
function extern_nmsp(text name)

function extern_func(type t, text name, sequence header)

function extern_meth(type t, text name, sequence header)

function as_eu_obj(object obj)

function as_clr_obj(object obj)


-- variables
object z = 4

-- constants
constant A = 9
constant object Z = 4 -- explicit constant type

-- functions
function sum(atom x, atom y)
    return x + y
end

function sum(atom x, atom y) => x + y -- syntax sugar

function atom sum(atom x, atom y) => x + y -- with returned type (probably, later)

function sum = (x, y) => x + y -- lambda function
 
-- types
contract positive(atom a)
    return a > 0
end

type person
    readonly text name -- only getter
    age age
end

readonly type point
    atom x
    atom y
end

readonly sequence s = { 4, 5, 1, 2, 3, 4 }
constant s = readonly { 3, 4, 5, 22 }

auto p = readonly point.new(3, 4)

function readonly sequence print_all(readonly sequence s)

function iterable:get_mixin(object x)
    return x.as_stream()
end

function mixin(type t)
    return delegate:new(t, t.get_mixin())
end

type point
    by iterable((self) => { self.x, self.y })

    atom x
    atom y

    atom sum by property(
        get = self => self.x + self.y
    )

    atom sum by (self, property, oldValue, newValue, isGetter) ->
        if isGetter then
            return self.x + self.y
        end
    end
end

type division_by_zero : error
end

type sin : object
end

type color : enum
end

fail message ~ return error.new(message)
integer! x = ...
integer!?

f() !! exit "sadasdass"

try
    f()
except 

-- 31.08.19
-- for cycle
-- nullable types
-- ?? operator
-- exit operator

-- 01.09.19
-- generators
-- sequence type
-- iterator type